/*
 * Dropbox Sign API
 *
 * Dropbox Sign v3 API
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: apisupport@hellosign.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using HelloSign.Client;
using HelloSign.Model;

namespace HelloSign.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISignatureRequestApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Embedded Bulk Send with Template
        /// </summary>
        /// <remarks>
        /// Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.  **NOTE**: Only available for Standard plan and higher.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BulkSendJobSendResponse</returns>
        BulkSendJobSendResponse SignatureRequestBulkCreateEmbeddedWithTemplate(SignatureRequestBulkCreateEmbeddedWithTemplateRequest signatureRequestBulkCreateEmbeddedWithTemplateRequest, int operationIndex = 0);

        /// <summary>
        /// Embedded Bulk Send with Template
        /// </summary>
        /// <remarks>
        /// Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.  **NOTE**: Only available for Standard plan and higher.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BulkSendJobSendResponse</returns>
        ApiResponse<BulkSendJobSendResponse> SignatureRequestBulkCreateEmbeddedWithTemplateWithHttpInfo(SignatureRequestBulkCreateEmbeddedWithTemplateRequest signatureRequestBulkCreateEmbeddedWithTemplateRequest, int operationIndex = 0);
        /// <summary>
        /// Bulk Send with Template
        /// </summary>
        /// <remarks>
        /// Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter.  **NOTE**: Only available for Standard plan and higher.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BulkSendJobSendResponse</returns>
        BulkSendJobSendResponse SignatureRequestBulkSendWithTemplate(SignatureRequestBulkSendWithTemplateRequest signatureRequestBulkSendWithTemplateRequest, int operationIndex = 0);

        /// <summary>
        /// Bulk Send with Template
        /// </summary>
        /// <remarks>
        /// Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter.  **NOTE**: Only available for Standard plan and higher.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BulkSendJobSendResponse</returns>
        ApiResponse<BulkSendJobSendResponse> SignatureRequestBulkSendWithTemplateWithHttpInfo(SignatureRequestBulkSendWithTemplateRequest signatureRequestBulkSendWithTemplateRequest, int operationIndex = 0);
        /// <summary>
        /// Cancel Incomplete Signature Request
        /// </summary>
        /// <remarks>
        /// Cancels an incomplete signature request. This action is **not reversible**.  The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.  This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the &#x60;signature_request_canceled&#x60; event. It is recommended that a  [callback handler](/api/reference/tag/Callbacks-and-Events) be implemented to listen for the &#x60;signature_request_canceled&#x60; event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.  To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.  **NOTE**: To remove your access to a completed signature request, use the endpoint: &#x60;POST /signature_request/remove/[:signature_request_id]&#x60;.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the incomplete SignatureRequest to cancel.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void SignatureRequestCancel(string signatureRequestId, int operationIndex = 0);

        /// <summary>
        /// Cancel Incomplete Signature Request
        /// </summary>
        /// <remarks>
        /// Cancels an incomplete signature request. This action is **not reversible**.  The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.  This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the &#x60;signature_request_canceled&#x60; event. It is recommended that a  [callback handler](/api/reference/tag/Callbacks-and-Events) be implemented to listen for the &#x60;signature_request_canceled&#x60; event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.  To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.  **NOTE**: To remove your access to a completed signature request, use the endpoint: &#x60;POST /signature_request/remove/[:signature_request_id]&#x60;.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the incomplete SignatureRequest to cancel.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SignatureRequestCancelWithHttpInfo(string signatureRequestId, int operationIndex = 0);
        /// <summary>
        /// Create Embedded Signature Request
        /// </summary>
        /// <remarks>
        /// Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        SignatureRequestGetResponse SignatureRequestCreateEmbedded(SignatureRequestCreateEmbeddedRequest signatureRequestCreateEmbeddedRequest, int operationIndex = 0);

        /// <summary>
        /// Create Embedded Signature Request
        /// </summary>
        /// <remarks>
        /// Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        ApiResponse<SignatureRequestGetResponse> SignatureRequestCreateEmbeddedWithHttpInfo(SignatureRequestCreateEmbeddedRequest signatureRequestCreateEmbeddedRequest, int operationIndex = 0);
        /// <summary>
        /// Create Embedded Signature Request with Template
        /// </summary>
        /// <remarks>
        /// Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        SignatureRequestGetResponse SignatureRequestCreateEmbeddedWithTemplate(SignatureRequestCreateEmbeddedWithTemplateRequest signatureRequestCreateEmbeddedWithTemplateRequest, int operationIndex = 0);

        /// <summary>
        /// Create Embedded Signature Request with Template
        /// </summary>
        /// <remarks>
        /// Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        ApiResponse<SignatureRequestGetResponse> SignatureRequestCreateEmbeddedWithTemplateWithHttpInfo(SignatureRequestCreateEmbeddedWithTemplateRequest signatureRequestCreateEmbeddedWithTemplateRequest, int operationIndex = 0);
        /// <summary>
        /// Download File
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a PDF or ZIP file.   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="fileType">Set to &#x60;pdf&#x60; for a single merged document or &#x60;zip&#x60; for a collection of individual documents. (optional, default to pdf)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>System.IO.Stream</returns>
        System.IO.Stream SignatureRequestFiles(string signatureRequestId, string? fileType = default(string?), int operationIndex = 0);

        /// <summary>
        /// Download File
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a PDF or ZIP file.   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="fileType">Set to &#x60;pdf&#x60; for a single merged document or &#x60;zip&#x60; for a collection of individual documents. (optional, default to pdf)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        ApiResponse<System.IO.Stream> SignatureRequestFilesWithHttpInfo(string signatureRequestId, string? fileType = default(string?), int operationIndex = 0);
        /// <summary>
        /// Download File as Encoded String
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a &#x60;data_uri&#x60; representing the base64 encoded file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponseDataUri</returns>
        FileResponseDataUri SignatureRequestFilesAsEncodedString(string signatureRequestId, int operationIndex = 0);

        /// <summary>
        /// Download File as Encoded String
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a &#x60;data_uri&#x60; representing the base64 encoded file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponseDataUri</returns>
        ApiResponse<FileResponseDataUri> SignatureRequestFilesAsEncodedStringWithHttpInfo(string signatureRequestId, int operationIndex = 0);
        /// <summary>
        /// Download File as File Url
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a url to the file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponse</returns>
        FileResponse SignatureRequestFilesAsFileUrl(string signatureRequestId, int operationIndex = 0);

        /// <summary>
        /// Download File as File Url
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a url to the file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponse</returns>
        ApiResponse<FileResponse> SignatureRequestFilesAsFileUrlWithHttpInfo(string signatureRequestId, int operationIndex = 0);
        /// <summary>
        /// Get Signature Request
        /// </summary>
        /// <remarks>
        /// Returns the status of the SignatureRequest specified by the &#x60;signature_request_id&#x60; parameter.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        SignatureRequestGetResponse SignatureRequestGet(string signatureRequestId, int operationIndex = 0);

        /// <summary>
        /// Get Signature Request
        /// </summary>
        /// <remarks>
        /// Returns the status of the SignatureRequest specified by the &#x60;signature_request_id&#x60; parameter.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        ApiResponse<SignatureRequestGetResponse> SignatureRequestGetWithHttpInfo(string signatureRequestId, int operationIndex = 0);
        /// <summary>
        /// List Signature Requests
        /// </summary>
        /// <remarks>
        /// Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.  Take a look at our [search guide](/api/reference/search/) to learn more about querying signature requests.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">Which account to return SignatureRequests for. Must be a team member. Use &#x60;all&#x60; to indicate all team members. Defaults to your account. (optional)</param>
        /// <param name="page">Which page number of the SignatureRequest List to return. Defaults to &#x60;1&#x60;. (optional, default to 1)</param>
        /// <param name="pageSize">Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;. (optional, default to 20)</param>
        /// <param name="query">String that includes search terms and/or fields to be used to filter the SignatureRequest objects. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestListResponse</returns>
        SignatureRequestListResponse SignatureRequestList(string? accountId = default(string?), int? page = default(int?), int? pageSize = default(int?), string? query = default(string?), int operationIndex = 0);

        /// <summary>
        /// List Signature Requests
        /// </summary>
        /// <remarks>
        /// Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.  Take a look at our [search guide](/api/reference/search/) to learn more about querying signature requests.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">Which account to return SignatureRequests for. Must be a team member. Use &#x60;all&#x60; to indicate all team members. Defaults to your account. (optional)</param>
        /// <param name="page">Which page number of the SignatureRequest List to return. Defaults to &#x60;1&#x60;. (optional, default to 1)</param>
        /// <param name="pageSize">Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;. (optional, default to 20)</param>
        /// <param name="query">String that includes search terms and/or fields to be used to filter the SignatureRequest objects. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestListResponse</returns>
        ApiResponse<SignatureRequestListResponse> SignatureRequestListWithHttpInfo(string? accountId = default(string?), int? page = default(int?), int? pageSize = default(int?), string? query = default(string?), int operationIndex = 0);
        /// <summary>
        /// Release On-Hold Signature Request
        /// </summary>
        /// <remarks>
        /// Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](/api/reference/tag/Unclaimed-Draft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to release.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        SignatureRequestGetResponse SignatureRequestReleaseHold(string signatureRequestId, int operationIndex = 0);

        /// <summary>
        /// Release On-Hold Signature Request
        /// </summary>
        /// <remarks>
        /// Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](/api/reference/tag/Unclaimed-Draft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to release.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        ApiResponse<SignatureRequestGetResponse> SignatureRequestReleaseHoldWithHttpInfo(string signatureRequestId, int operationIndex = 0);
        /// <summary>
        /// Send Request Reminder
        /// </summary>
        /// <remarks>
        /// Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.  **NOTE**: This action can **not** be used with embedded signature requests.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to send a reminder for.</param>
        /// <param name="signatureRequestRemindRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        SignatureRequestGetResponse SignatureRequestRemind(string signatureRequestId, SignatureRequestRemindRequest signatureRequestRemindRequest, int operationIndex = 0);

        /// <summary>
        /// Send Request Reminder
        /// </summary>
        /// <remarks>
        /// Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.  **NOTE**: This action can **not** be used with embedded signature requests.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to send a reminder for.</param>
        /// <param name="signatureRequestRemindRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        ApiResponse<SignatureRequestGetResponse> SignatureRequestRemindWithHttpInfo(string signatureRequestId, SignatureRequestRemindRequest signatureRequestRemindRequest, int operationIndex = 0);
        /// <summary>
        /// Remove Signature Request Access
        /// </summary>
        /// <remarks>
        /// Removes your access to a completed signature request. This action is **not reversible**.  The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).  Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to remove.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void SignatureRequestRemove(string signatureRequestId, int operationIndex = 0);

        /// <summary>
        /// Remove Signature Request Access
        /// </summary>
        /// <remarks>
        /// Removes your access to a completed signature request. This action is **not reversible**.  The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).  Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to remove.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SignatureRequestRemoveWithHttpInfo(string signatureRequestId, int operationIndex = 0);
        /// <summary>
        /// Send Signature Request
        /// </summary>
        /// <remarks>
        /// Creates and sends a new SignatureRequest with the submitted documents. If &#x60;form_fields_per_document&#x60; is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        SignatureRequestGetResponse SignatureRequestSend(SignatureRequestSendRequest signatureRequestSendRequest, int operationIndex = 0);

        /// <summary>
        /// Send Signature Request
        /// </summary>
        /// <remarks>
        /// Creates and sends a new SignatureRequest with the submitted documents. If &#x60;form_fields_per_document&#x60; is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        ApiResponse<SignatureRequestGetResponse> SignatureRequestSendWithHttpInfo(SignatureRequestSendRequest signatureRequestSendRequest, int operationIndex = 0);
        /// <summary>
        /// Send with Template
        /// </summary>
        /// <remarks>
        /// Creates and sends a new SignatureRequest based off of the Template(s) specified with the &#x60;template_ids&#x60; parameter.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        SignatureRequestGetResponse SignatureRequestSendWithTemplate(SignatureRequestSendWithTemplateRequest signatureRequestSendWithTemplateRequest, int operationIndex = 0);

        /// <summary>
        /// Send with Template
        /// </summary>
        /// <remarks>
        /// Creates and sends a new SignatureRequest based off of the Template(s) specified with the &#x60;template_ids&#x60; parameter.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        ApiResponse<SignatureRequestGetResponse> SignatureRequestSendWithTemplateWithHttpInfo(SignatureRequestSendWithTemplateRequest signatureRequestSendWithTemplateRequest, int operationIndex = 0);
        /// <summary>
        /// Update Signature Request
        /// </summary>
        /// <remarks>
        /// Updates the email address and/or the name for a given signer on a signature request. You can listen for the &#x60;signature_request_email_bounce&#x60; event on your app or account to detect bounced emails, and respond with this method.  **NOTE**: This action cannot be performed on a signature request with an appended signature page.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to update.</param>
        /// <param name="signatureRequestUpdateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        SignatureRequestGetResponse SignatureRequestUpdate(string signatureRequestId, SignatureRequestUpdateRequest signatureRequestUpdateRequest, int operationIndex = 0);

        /// <summary>
        /// Update Signature Request
        /// </summary>
        /// <remarks>
        /// Updates the email address and/or the name for a given signer on a signature request. You can listen for the &#x60;signature_request_email_bounce&#x60; event on your app or account to detect bounced emails, and respond with this method.  **NOTE**: This action cannot be performed on a signature request with an appended signature page.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to update.</param>
        /// <param name="signatureRequestUpdateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        ApiResponse<SignatureRequestGetResponse> SignatureRequestUpdateWithHttpInfo(string signatureRequestId, SignatureRequestUpdateRequest signatureRequestUpdateRequest, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISignatureRequestApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Embedded Bulk Send with Template
        /// </summary>
        /// <remarks>
        /// Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.  **NOTE**: Only available for Standard plan and higher.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BulkSendJobSendResponse</returns>
        System.Threading.Tasks.Task<BulkSendJobSendResponse> SignatureRequestBulkCreateEmbeddedWithTemplateAsync(SignatureRequestBulkCreateEmbeddedWithTemplateRequest signatureRequestBulkCreateEmbeddedWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Embedded Bulk Send with Template
        /// </summary>
        /// <remarks>
        /// Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.  **NOTE**: Only available for Standard plan and higher.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BulkSendJobSendResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<BulkSendJobSendResponse>> SignatureRequestBulkCreateEmbeddedWithTemplateWithHttpInfoAsync(SignatureRequestBulkCreateEmbeddedWithTemplateRequest signatureRequestBulkCreateEmbeddedWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Bulk Send with Template
        /// </summary>
        /// <remarks>
        /// Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter.  **NOTE**: Only available for Standard plan and higher.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BulkSendJobSendResponse</returns>
        System.Threading.Tasks.Task<BulkSendJobSendResponse> SignatureRequestBulkSendWithTemplateAsync(SignatureRequestBulkSendWithTemplateRequest signatureRequestBulkSendWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Bulk Send with Template
        /// </summary>
        /// <remarks>
        /// Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter.  **NOTE**: Only available for Standard plan and higher.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BulkSendJobSendResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<BulkSendJobSendResponse>> SignatureRequestBulkSendWithTemplateWithHttpInfoAsync(SignatureRequestBulkSendWithTemplateRequest signatureRequestBulkSendWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Cancel Incomplete Signature Request
        /// </summary>
        /// <remarks>
        /// Cancels an incomplete signature request. This action is **not reversible**.  The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.  This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the &#x60;signature_request_canceled&#x60; event. It is recommended that a  [callback handler](/api/reference/tag/Callbacks-and-Events) be implemented to listen for the &#x60;signature_request_canceled&#x60; event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.  To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.  **NOTE**: To remove your access to a completed signature request, use the endpoint: &#x60;POST /signature_request/remove/[:signature_request_id]&#x60;.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the incomplete SignatureRequest to cancel.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SignatureRequestCancelAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Cancel Incomplete Signature Request
        /// </summary>
        /// <remarks>
        /// Cancels an incomplete signature request. This action is **not reversible**.  The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.  This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the &#x60;signature_request_canceled&#x60; event. It is recommended that a  [callback handler](/api/reference/tag/Callbacks-and-Events) be implemented to listen for the &#x60;signature_request_canceled&#x60; event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.  To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.  **NOTE**: To remove your access to a completed signature request, use the endpoint: &#x60;POST /signature_request/remove/[:signature_request_id]&#x60;.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the incomplete SignatureRequest to cancel.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SignatureRequestCancelWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create Embedded Signature Request
        /// </summary>
        /// <remarks>
        /// Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestCreateEmbeddedAsync(SignatureRequestCreateEmbeddedRequest signatureRequestCreateEmbeddedRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create Embedded Signature Request
        /// </summary>
        /// <remarks>
        /// Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureRequestGetResponse>> SignatureRequestCreateEmbeddedWithHttpInfoAsync(SignatureRequestCreateEmbeddedRequest signatureRequestCreateEmbeddedRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create Embedded Signature Request with Template
        /// </summary>
        /// <remarks>
        /// Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestCreateEmbeddedWithTemplateAsync(SignatureRequestCreateEmbeddedWithTemplateRequest signatureRequestCreateEmbeddedWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create Embedded Signature Request with Template
        /// </summary>
        /// <remarks>
        /// Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureRequestGetResponse>> SignatureRequestCreateEmbeddedWithTemplateWithHttpInfoAsync(SignatureRequestCreateEmbeddedWithTemplateRequest signatureRequestCreateEmbeddedWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Download File
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a PDF or ZIP file.   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="fileType">Set to &#x60;pdf&#x60; for a single merged document or &#x60;zip&#x60; for a collection of individual documents. (optional, default to pdf)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of System.IO.Stream</returns>
        System.Threading.Tasks.Task<System.IO.Stream> SignatureRequestFilesAsync(string signatureRequestId, string? fileType = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Download File
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a PDF or ZIP file.   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="fileType">Set to &#x60;pdf&#x60; for a single merged document or &#x60;zip&#x60; for a collection of individual documents. (optional, default to pdf)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        System.Threading.Tasks.Task<ApiResponse<System.IO.Stream>> SignatureRequestFilesWithHttpInfoAsync(string signatureRequestId, string? fileType = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Download File as Encoded String
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a &#x60;data_uri&#x60; representing the base64 encoded file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponseDataUri</returns>
        System.Threading.Tasks.Task<FileResponseDataUri> SignatureRequestFilesAsEncodedStringAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Download File as Encoded String
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a &#x60;data_uri&#x60; representing the base64 encoded file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponseDataUri)</returns>
        System.Threading.Tasks.Task<ApiResponse<FileResponseDataUri>> SignatureRequestFilesAsEncodedStringWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Download File as File Url
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a url to the file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponse</returns>
        System.Threading.Tasks.Task<FileResponse> SignatureRequestFilesAsFileUrlAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Download File as File Url
        /// </summary>
        /// <remarks>
        /// Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a url to the file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<FileResponse>> SignatureRequestFilesAsFileUrlWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Signature Request
        /// </summary>
        /// <remarks>
        /// Returns the status of the SignatureRequest specified by the &#x60;signature_request_id&#x60; parameter.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestGetAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Signature Request
        /// </summary>
        /// <remarks>
        /// Returns the status of the SignatureRequest specified by the &#x60;signature_request_id&#x60; parameter.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureRequestGetResponse>> SignatureRequestGetWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List Signature Requests
        /// </summary>
        /// <remarks>
        /// Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.  Take a look at our [search guide](/api/reference/search/) to learn more about querying signature requests.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">Which account to return SignatureRequests for. Must be a team member. Use &#x60;all&#x60; to indicate all team members. Defaults to your account. (optional)</param>
        /// <param name="page">Which page number of the SignatureRequest List to return. Defaults to &#x60;1&#x60;. (optional, default to 1)</param>
        /// <param name="pageSize">Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;. (optional, default to 20)</param>
        /// <param name="query">String that includes search terms and/or fields to be used to filter the SignatureRequest objects. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestListResponse</returns>
        System.Threading.Tasks.Task<SignatureRequestListResponse> SignatureRequestListAsync(string? accountId = default(string?), int? page = default(int?), int? pageSize = default(int?), string? query = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List Signature Requests
        /// </summary>
        /// <remarks>
        /// Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.  Take a look at our [search guide](/api/reference/search/) to learn more about querying signature requests.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">Which account to return SignatureRequests for. Must be a team member. Use &#x60;all&#x60; to indicate all team members. Defaults to your account. (optional)</param>
        /// <param name="page">Which page number of the SignatureRequest List to return. Defaults to &#x60;1&#x60;. (optional, default to 1)</param>
        /// <param name="pageSize">Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;. (optional, default to 20)</param>
        /// <param name="query">String that includes search terms and/or fields to be used to filter the SignatureRequest objects. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestListResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureRequestListResponse>> SignatureRequestListWithHttpInfoAsync(string? accountId = default(string?), int? page = default(int?), int? pageSize = default(int?), string? query = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Release On-Hold Signature Request
        /// </summary>
        /// <remarks>
        /// Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](/api/reference/tag/Unclaimed-Draft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to release.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestReleaseHoldAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Release On-Hold Signature Request
        /// </summary>
        /// <remarks>
        /// Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](/api/reference/tag/Unclaimed-Draft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to release.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureRequestGetResponse>> SignatureRequestReleaseHoldWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send Request Reminder
        /// </summary>
        /// <remarks>
        /// Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.  **NOTE**: This action can **not** be used with embedded signature requests.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to send a reminder for.</param>
        /// <param name="signatureRequestRemindRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestRemindAsync(string signatureRequestId, SignatureRequestRemindRequest signatureRequestRemindRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send Request Reminder
        /// </summary>
        /// <remarks>
        /// Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.  **NOTE**: This action can **not** be used with embedded signature requests.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to send a reminder for.</param>
        /// <param name="signatureRequestRemindRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureRequestGetResponse>> SignatureRequestRemindWithHttpInfoAsync(string signatureRequestId, SignatureRequestRemindRequest signatureRequestRemindRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Remove Signature Request Access
        /// </summary>
        /// <remarks>
        /// Removes your access to a completed signature request. This action is **not reversible**.  The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).  Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to remove.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SignatureRequestRemoveAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Remove Signature Request Access
        /// </summary>
        /// <remarks>
        /// Removes your access to a completed signature request. This action is **not reversible**.  The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).  Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to remove.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SignatureRequestRemoveWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send Signature Request
        /// </summary>
        /// <remarks>
        /// Creates and sends a new SignatureRequest with the submitted documents. If &#x60;form_fields_per_document&#x60; is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestSendAsync(SignatureRequestSendRequest signatureRequestSendRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send Signature Request
        /// </summary>
        /// <remarks>
        /// Creates and sends a new SignatureRequest with the submitted documents. If &#x60;form_fields_per_document&#x60; is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureRequestGetResponse>> SignatureRequestSendWithHttpInfoAsync(SignatureRequestSendRequest signatureRequestSendRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send with Template
        /// </summary>
        /// <remarks>
        /// Creates and sends a new SignatureRequest based off of the Template(s) specified with the &#x60;template_ids&#x60; parameter.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestSendWithTemplateAsync(SignatureRequestSendWithTemplateRequest signatureRequestSendWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send with Template
        /// </summary>
        /// <remarks>
        /// Creates and sends a new SignatureRequest based off of the Template(s) specified with the &#x60;template_ids&#x60; parameter.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureRequestGetResponse>> SignatureRequestSendWithTemplateWithHttpInfoAsync(SignatureRequestSendWithTemplateRequest signatureRequestSendWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update Signature Request
        /// </summary>
        /// <remarks>
        /// Updates the email address and/or the name for a given signer on a signature request. You can listen for the &#x60;signature_request_email_bounce&#x60; event on your app or account to detect bounced emails, and respond with this method.  **NOTE**: This action cannot be performed on a signature request with an appended signature page.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to update.</param>
        /// <param name="signatureRequestUpdateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestUpdateAsync(string signatureRequestId, SignatureRequestUpdateRequest signatureRequestUpdateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update Signature Request
        /// </summary>
        /// <remarks>
        /// Updates the email address and/or the name for a given signer on a signature request. You can listen for the &#x60;signature_request_email_bounce&#x60; event on your app or account to detect bounced emails, and respond with this method.  **NOTE**: This action cannot be performed on a signature request with an appended signature page.
        /// </remarks>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to update.</param>
        /// <param name="signatureRequestUpdateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureRequestGetResponse>> SignatureRequestUpdateWithHttpInfoAsync(string signatureRequestId, SignatureRequestUpdateRequest signatureRequestUpdateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISignatureRequestApi : ISignatureRequestApiSync, ISignatureRequestApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class SignatureRequestApi : ISignatureRequestApi
    {
        private HelloSign.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SignatureRequestApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SignatureRequestApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SignatureRequestApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SignatureRequestApi(string basePath)
        {
            this.Configuration = HelloSign.Client.Configuration.MergeConfigurations(
                HelloSign.Client.GlobalConfiguration.Instance,
                new HelloSign.Client.Configuration { BasePath = basePath }
            );
            this.Client = new HelloSign.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new HelloSign.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = HelloSign.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SignatureRequestApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SignatureRequestApi(HelloSign.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = HelloSign.Client.Configuration.MergeConfigurations(
                HelloSign.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new HelloSign.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new HelloSign.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = HelloSign.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SignatureRequestApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public SignatureRequestApi(HelloSign.Client.ISynchronousClient client, HelloSign.Client.IAsynchronousClient asyncClient, HelloSign.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = HelloSign.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public HelloSign.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public HelloSign.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public HelloSign.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public HelloSign.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Embedded Bulk Send with Template Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.  **NOTE**: Only available for Standard plan and higher.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BulkSendJobSendResponse</returns>
        public BulkSendJobSendResponse SignatureRequestBulkCreateEmbeddedWithTemplate(SignatureRequestBulkCreateEmbeddedWithTemplateRequest signatureRequestBulkCreateEmbeddedWithTemplateRequest, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<BulkSendJobSendResponse> localVarResponse = SignatureRequestBulkCreateEmbeddedWithTemplateWithHttpInfo(signatureRequestBulkCreateEmbeddedWithTemplateRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Embedded Bulk Send with Template Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.  **NOTE**: Only available for Standard plan and higher.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BulkSendJobSendResponse</returns>
        public HelloSign.Client.ApiResponse<BulkSendJobSendResponse> SignatureRequestBulkCreateEmbeddedWithTemplateWithHttpInfo(SignatureRequestBulkCreateEmbeddedWithTemplateRequest signatureRequestBulkCreateEmbeddedWithTemplateRequest, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestBulkCreateEmbeddedWithTemplateRequest' is set
            if (signatureRequestBulkCreateEmbeddedWithTemplateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestBulkCreateEmbeddedWithTemplateRequest' when calling SignatureRequestApi->SignatureRequestBulkCreateEmbeddedWithTemplate");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestBulkCreateEmbeddedWithTemplateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestBulkCreateEmbeddedWithTemplateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestBulkCreateEmbeddedWithTemplate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<BulkSendJobSendResponse>("/signature_request/bulk_create_embedded_with_template", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestBulkCreateEmbeddedWithTemplate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Embedded Bulk Send with Template Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.  **NOTE**: Only available for Standard plan and higher.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BulkSendJobSendResponse</returns>
        public async System.Threading.Tasks.Task<BulkSendJobSendResponse> SignatureRequestBulkCreateEmbeddedWithTemplateAsync(SignatureRequestBulkCreateEmbeddedWithTemplateRequest signatureRequestBulkCreateEmbeddedWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<BulkSendJobSendResponse> localVarResponse = await SignatureRequestBulkCreateEmbeddedWithTemplateWithHttpInfoAsync(signatureRequestBulkCreateEmbeddedWithTemplateRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Embedded Bulk Send with Template Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter to be signed in an embedded iFrame. These embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.  **NOTE**: Only available for Standard plan and higher.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BulkSendJobSendResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<BulkSendJobSendResponse>> SignatureRequestBulkCreateEmbeddedWithTemplateWithHttpInfoAsync(SignatureRequestBulkCreateEmbeddedWithTemplateRequest signatureRequestBulkCreateEmbeddedWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestBulkCreateEmbeddedWithTemplateRequest' is set
            if (signatureRequestBulkCreateEmbeddedWithTemplateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestBulkCreateEmbeddedWithTemplateRequest' when calling SignatureRequestApi->SignatureRequestBulkCreateEmbeddedWithTemplate");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestBulkCreateEmbeddedWithTemplateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestBulkCreateEmbeddedWithTemplateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestBulkCreateEmbeddedWithTemplate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<BulkSendJobSendResponse>("/signature_request/bulk_create_embedded_with_template", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestBulkCreateEmbeddedWithTemplate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Bulk Send with Template Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter.  **NOTE**: Only available for Standard plan and higher.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>BulkSendJobSendResponse</returns>
        public BulkSendJobSendResponse SignatureRequestBulkSendWithTemplate(SignatureRequestBulkSendWithTemplateRequest signatureRequestBulkSendWithTemplateRequest, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<BulkSendJobSendResponse> localVarResponse = SignatureRequestBulkSendWithTemplateWithHttpInfo(signatureRequestBulkSendWithTemplateRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Bulk Send with Template Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter.  **NOTE**: Only available for Standard plan and higher.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of BulkSendJobSendResponse</returns>
        public HelloSign.Client.ApiResponse<BulkSendJobSendResponse> SignatureRequestBulkSendWithTemplateWithHttpInfo(SignatureRequestBulkSendWithTemplateRequest signatureRequestBulkSendWithTemplateRequest, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestBulkSendWithTemplateRequest' is set
            if (signatureRequestBulkSendWithTemplateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestBulkSendWithTemplateRequest' when calling SignatureRequestApi->SignatureRequestBulkSendWithTemplate");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestBulkSendWithTemplateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestBulkSendWithTemplateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestBulkSendWithTemplate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<BulkSendJobSendResponse>("/signature_request/bulk_send_with_template", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestBulkSendWithTemplate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Bulk Send with Template Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter.  **NOTE**: Only available for Standard plan and higher.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BulkSendJobSendResponse</returns>
        public async System.Threading.Tasks.Task<BulkSendJobSendResponse> SignatureRequestBulkSendWithTemplateAsync(SignatureRequestBulkSendWithTemplateRequest signatureRequestBulkSendWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<BulkSendJobSendResponse> localVarResponse = await SignatureRequestBulkSendWithTemplateWithHttpInfoAsync(signatureRequestBulkSendWithTemplateRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Bulk Send with Template Creates BulkSendJob which sends up to 250 SignatureRequests in bulk based off of the provided Template(s) specified with the &#x60;template_ids&#x60; parameter.  **NOTE**: Only available for Standard plan and higher.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestBulkSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BulkSendJobSendResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<BulkSendJobSendResponse>> SignatureRequestBulkSendWithTemplateWithHttpInfoAsync(SignatureRequestBulkSendWithTemplateRequest signatureRequestBulkSendWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestBulkSendWithTemplateRequest' is set
            if (signatureRequestBulkSendWithTemplateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestBulkSendWithTemplateRequest' when calling SignatureRequestApi->SignatureRequestBulkSendWithTemplate");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestBulkSendWithTemplateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestBulkSendWithTemplateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestBulkSendWithTemplate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<BulkSendJobSendResponse>("/signature_request/bulk_send_with_template", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestBulkSendWithTemplate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel Incomplete Signature Request Cancels an incomplete signature request. This action is **not reversible**.  The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.  This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the &#x60;signature_request_canceled&#x60; event. It is recommended that a  [callback handler](/api/reference/tag/Callbacks-and-Events) be implemented to listen for the &#x60;signature_request_canceled&#x60; event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.  To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.  **NOTE**: To remove your access to a completed signature request, use the endpoint: &#x60;POST /signature_request/remove/[:signature_request_id]&#x60;.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the incomplete SignatureRequest to cancel.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void SignatureRequestCancel(string signatureRequestId, int operationIndex = 0)
        {
            SignatureRequestCancelWithHttpInfo(signatureRequestId);
        }

        /// <summary>
        /// Cancel Incomplete Signature Request Cancels an incomplete signature request. This action is **not reversible**.  The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.  This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the &#x60;signature_request_canceled&#x60; event. It is recommended that a  [callback handler](/api/reference/tag/Callbacks-and-Events) be implemented to listen for the &#x60;signature_request_canceled&#x60; event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.  To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.  **NOTE**: To remove your access to a completed signature request, use the endpoint: &#x60;POST /signature_request/remove/[:signature_request_id]&#x60;.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the incomplete SignatureRequest to cancel.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public HelloSign.Client.ApiResponse<Object> SignatureRequestCancelWithHttpInfo(string signatureRequestId, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestCancel");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };
            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestCancel";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/signature_request/cancel/{signature_request_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestCancel", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel Incomplete Signature Request Cancels an incomplete signature request. This action is **not reversible**.  The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.  This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the &#x60;signature_request_canceled&#x60; event. It is recommended that a  [callback handler](/api/reference/tag/Callbacks-and-Events) be implemented to listen for the &#x60;signature_request_canceled&#x60; event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.  To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.  **NOTE**: To remove your access to a completed signature request, use the endpoint: &#x60;POST /signature_request/remove/[:signature_request_id]&#x60;.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the incomplete SignatureRequest to cancel.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SignatureRequestCancelAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await SignatureRequestCancelWithHttpInfoAsync(signatureRequestId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Cancel Incomplete Signature Request Cancels an incomplete signature request. This action is **not reversible**.  The request will be canceled and signers will no longer be able to sign. If they try to access the signature request they will receive a HTTP 410 status code indicating that the resource has been deleted. Cancelation is asynchronous and a successful call to this endpoint will return an empty 200 OK response if the signature request is eligible to be canceled and has been successfully queued.  This 200 OK response does not indicate a successful cancelation of the signature request itself. The cancelation is confirmed via the &#x60;signature_request_canceled&#x60; event. It is recommended that a  [callback handler](/api/reference/tag/Callbacks-and-Events) be implemented to listen for the &#x60;signature_request_canceled&#x60; event. This callback will be sent only when the cancelation has completed successfully. If a callback handler has been configured and the event has not been received within 60 minutes of making the call, check the status of the request in the [API Dashboard](https://app.hellosign.com/apidashboard) and retry the cancelation if necessary.  To be eligible for cancelation, a signature request must have been sent successfully, must not yet have been signed by all signers, and you must either be the sender or own the API app under which it was sent. A partially signed signature request can be canceled.  **NOTE**: To remove your access to a completed signature request, use the endpoint: &#x60;POST /signature_request/remove/[:signature_request_id]&#x60;.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the incomplete SignatureRequest to cancel.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<Object>> SignatureRequestCancelWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestCancel");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestCancel";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/signature_request/cancel/{signature_request_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestCancel", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create Embedded Signature Request Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        public SignatureRequestGetResponse SignatureRequestCreateEmbedded(SignatureRequestCreateEmbeddedRequest signatureRequestCreateEmbeddedRequest, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = SignatureRequestCreateEmbeddedWithHttpInfo(signatureRequestCreateEmbeddedRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create Embedded Signature Request Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        public HelloSign.Client.ApiResponse<SignatureRequestGetResponse> SignatureRequestCreateEmbeddedWithHttpInfo(SignatureRequestCreateEmbeddedRequest signatureRequestCreateEmbeddedRequest, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestCreateEmbeddedRequest' is set
            if (signatureRequestCreateEmbeddedRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestCreateEmbeddedRequest' when calling SignatureRequestApi->SignatureRequestCreateEmbedded");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestCreateEmbeddedRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestCreateEmbeddedRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestCreateEmbedded";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SignatureRequestGetResponse>("/signature_request/create_embedded", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestCreateEmbedded", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create Embedded Signature Request Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        public async System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestCreateEmbeddedAsync(SignatureRequestCreateEmbeddedRequest signatureRequestCreateEmbeddedRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = await SignatureRequestCreateEmbeddedWithHttpInfoAsync(signatureRequestCreateEmbeddedRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create Embedded Signature Request Creates a new SignatureRequest with the submitted documents to be signed in an embedded iFrame. If form_fields_per_document is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<SignatureRequestGetResponse>> SignatureRequestCreateEmbeddedWithHttpInfoAsync(SignatureRequestCreateEmbeddedRequest signatureRequestCreateEmbeddedRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestCreateEmbeddedRequest' is set
            if (signatureRequestCreateEmbeddedRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestCreateEmbeddedRequest' when calling SignatureRequestApi->SignatureRequestCreateEmbedded");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestCreateEmbeddedRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestCreateEmbeddedRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestCreateEmbedded";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SignatureRequestGetResponse>("/signature_request/create_embedded", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestCreateEmbedded", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create Embedded Signature Request with Template Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        public SignatureRequestGetResponse SignatureRequestCreateEmbeddedWithTemplate(SignatureRequestCreateEmbeddedWithTemplateRequest signatureRequestCreateEmbeddedWithTemplateRequest, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = SignatureRequestCreateEmbeddedWithTemplateWithHttpInfo(signatureRequestCreateEmbeddedWithTemplateRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create Embedded Signature Request with Template Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        public HelloSign.Client.ApiResponse<SignatureRequestGetResponse> SignatureRequestCreateEmbeddedWithTemplateWithHttpInfo(SignatureRequestCreateEmbeddedWithTemplateRequest signatureRequestCreateEmbeddedWithTemplateRequest, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestCreateEmbeddedWithTemplateRequest' is set
            if (signatureRequestCreateEmbeddedWithTemplateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestCreateEmbeddedWithTemplateRequest' when calling SignatureRequestApi->SignatureRequestCreateEmbeddedWithTemplate");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestCreateEmbeddedWithTemplateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestCreateEmbeddedWithTemplateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestCreateEmbeddedWithTemplate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SignatureRequestGetResponse>("/signature_request/create_embedded_with_template", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestCreateEmbeddedWithTemplate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create Embedded Signature Request with Template Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        public async System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestCreateEmbeddedWithTemplateAsync(SignatureRequestCreateEmbeddedWithTemplateRequest signatureRequestCreateEmbeddedWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = await SignatureRequestCreateEmbeddedWithTemplateWithHttpInfoAsync(signatureRequestCreateEmbeddedWithTemplateRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create Embedded Signature Request with Template Creates a new SignatureRequest based on the given Template(s) to be signed in an embedded iFrame. &lt;u&gt;Note&lt;/u&gt; that embedded signature requests can only be signed in embedded iFrames whereas normal signature requests can only be signed on Dropbox Sign.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestCreateEmbeddedWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<SignatureRequestGetResponse>> SignatureRequestCreateEmbeddedWithTemplateWithHttpInfoAsync(SignatureRequestCreateEmbeddedWithTemplateRequest signatureRequestCreateEmbeddedWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestCreateEmbeddedWithTemplateRequest' is set
            if (signatureRequestCreateEmbeddedWithTemplateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestCreateEmbeddedWithTemplateRequest' when calling SignatureRequestApi->SignatureRequestCreateEmbeddedWithTemplate");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestCreateEmbeddedWithTemplateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestCreateEmbeddedWithTemplateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestCreateEmbeddedWithTemplate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SignatureRequestGetResponse>("/signature_request/create_embedded_with_template", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestCreateEmbeddedWithTemplate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Download File Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a PDF or ZIP file.   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="fileType">Set to &#x60;pdf&#x60; for a single merged document or &#x60;zip&#x60; for a collection of individual documents. (optional, default to pdf)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>System.IO.Stream</returns>
        public System.IO.Stream SignatureRequestFiles(string signatureRequestId, string? fileType = default(string?), int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<System.IO.Stream> localVarResponse = SignatureRequestFilesWithHttpInfo(signatureRequestId, fileType);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Download File Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a PDF or ZIP file.   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="fileType">Set to &#x60;pdf&#x60; for a single merged document or &#x60;zip&#x60; for a collection of individual documents. (optional, default to pdf)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        public HelloSign.Client.ApiResponse<System.IO.Stream> SignatureRequestFilesWithHttpInfo(string signatureRequestId, string? fileType = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestFiles");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };
            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/pdf",
                "application/zip",
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            if (fileType != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "file_type", fileType));
            }
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestFiles";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<System.IO.Stream>("/signature_request/files/{signature_request_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestFiles", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Download File Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a PDF or ZIP file.   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="fileType">Set to &#x60;pdf&#x60; for a single merged document or &#x60;zip&#x60; for a collection of individual documents. (optional, default to pdf)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of System.IO.Stream</returns>
        public async System.Threading.Tasks.Task<System.IO.Stream> SignatureRequestFilesAsync(string signatureRequestId, string? fileType = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<System.IO.Stream> localVarResponse = await SignatureRequestFilesWithHttpInfoAsync(signatureRequestId, fileType, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Download File Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a PDF or ZIP file.   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="fileType">Set to &#x60;pdf&#x60; for a single merged document or &#x60;zip&#x60; for a collection of individual documents. (optional, default to pdf)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<System.IO.Stream>> SignatureRequestFilesWithHttpInfoAsync(string signatureRequestId, string? fileType = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestFiles");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/pdf",
                "application/zip",
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            if (fileType != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "file_type", fileType));
            }
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestFiles";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<System.IO.Stream>("/signature_request/files/{signature_request_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestFiles", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Download File as Encoded String Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a &#x60;data_uri&#x60; representing the base64 encoded file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponseDataUri</returns>
        public FileResponseDataUri SignatureRequestFilesAsEncodedString(string signatureRequestId, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<FileResponseDataUri> localVarResponse = SignatureRequestFilesAsEncodedStringWithHttpInfo(signatureRequestId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Download File as Encoded String Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a &#x60;data_uri&#x60; representing the base64 encoded file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponseDataUri</returns>
        public HelloSign.Client.ApiResponse<FileResponseDataUri> SignatureRequestFilesAsEncodedStringWithHttpInfo(string signatureRequestId, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestFilesAsEncodedString");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };
            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestFilesAsEncodedString";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<FileResponseDataUri>("/signature_request/files/{signature_request_id}?get_data_uri=1&file_type=pdf", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestFilesAsEncodedString", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Download File as Encoded String Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a &#x60;data_uri&#x60; representing the base64 encoded file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponseDataUri</returns>
        public async System.Threading.Tasks.Task<FileResponseDataUri> SignatureRequestFilesAsEncodedStringAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<FileResponseDataUri> localVarResponse = await SignatureRequestFilesAsEncodedStringWithHttpInfoAsync(signatureRequestId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Download File as Encoded String Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a &#x60;data_uri&#x60; representing the base64 encoded file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponseDataUri)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<FileResponseDataUri>> SignatureRequestFilesAsEncodedStringWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestFilesAsEncodedString");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestFilesAsEncodedString";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<FileResponseDataUri>("/signature_request/files/{signature_request_id}?get_data_uri=1&file_type=pdf", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestFilesAsEncodedString", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Download File as File Url Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a url to the file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>FileResponse</returns>
        public FileResponse SignatureRequestFilesAsFileUrl(string signatureRequestId, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<FileResponse> localVarResponse = SignatureRequestFilesAsFileUrlWithHttpInfo(signatureRequestId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Download File as File Url Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a url to the file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of FileResponse</returns>
        public HelloSign.Client.ApiResponse<FileResponse> SignatureRequestFilesAsFileUrlWithHttpInfo(string signatureRequestId, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestFilesAsFileUrl");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };
            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestFilesAsFileUrl";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<FileResponse>("/signature_request/files/{signature_request_id}?get_url=1&file_type=pdf", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestFilesAsFileUrl", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Download File as File Url Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a url to the file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of FileResponse</returns>
        public async System.Threading.Tasks.Task<FileResponse> SignatureRequestFilesAsFileUrlAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<FileResponse> localVarResponse = await SignatureRequestFilesAsFileUrlWithHttpInfoAsync(signatureRequestId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Download File as File Url Obtain a copy of the current documents specified by the &#x60;signature_request_id&#x60; parameter. Returns a JSON object with a url to the file (PDFs only).   If the files are currently being prepared, a status code of &#x60;409&#x60; will be returned instead.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (FileResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<FileResponse>> SignatureRequestFilesAsFileUrlWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestFilesAsFileUrl");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestFilesAsFileUrl";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<FileResponse>("/signature_request/files/{signature_request_id}?get_url=1&file_type=pdf", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestFilesAsFileUrl", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Signature Request Returns the status of the SignatureRequest specified by the &#x60;signature_request_id&#x60; parameter.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        public SignatureRequestGetResponse SignatureRequestGet(string signatureRequestId, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = SignatureRequestGetWithHttpInfo(signatureRequestId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Signature Request Returns the status of the SignatureRequest specified by the &#x60;signature_request_id&#x60; parameter.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        public HelloSign.Client.ApiResponse<SignatureRequestGetResponse> SignatureRequestGetWithHttpInfo(string signatureRequestId, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestGet");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };
            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SignatureRequestGetResponse>("/signature_request/{signature_request_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Signature Request Returns the status of the SignatureRequest specified by the &#x60;signature_request_id&#x60; parameter.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        public async System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestGetAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = await SignatureRequestGetWithHttpInfoAsync(signatureRequestId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Signature Request Returns the status of the SignatureRequest specified by the &#x60;signature_request_id&#x60; parameter.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to retrieve.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<SignatureRequestGetResponse>> SignatureRequestGetWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestGet");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestGet";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<SignatureRequestGetResponse>("/signature_request/{signature_request_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestGet", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Signature Requests Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.  Take a look at our [search guide](/api/reference/search/) to learn more about querying signature requests.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">Which account to return SignatureRequests for. Must be a team member. Use &#x60;all&#x60; to indicate all team members. Defaults to your account. (optional)</param>
        /// <param name="page">Which page number of the SignatureRequest List to return. Defaults to &#x60;1&#x60;. (optional, default to 1)</param>
        /// <param name="pageSize">Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;. (optional, default to 20)</param>
        /// <param name="query">String that includes search terms and/or fields to be used to filter the SignatureRequest objects. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestListResponse</returns>
        public SignatureRequestListResponse SignatureRequestList(string? accountId = default(string?), int? page = default(int?), int? pageSize = default(int?), string? query = default(string?), int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<SignatureRequestListResponse> localVarResponse = SignatureRequestListWithHttpInfo(accountId, page, pageSize, query);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Signature Requests Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.  Take a look at our [search guide](/api/reference/search/) to learn more about querying signature requests.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">Which account to return SignatureRequests for. Must be a team member. Use &#x60;all&#x60; to indicate all team members. Defaults to your account. (optional)</param>
        /// <param name="page">Which page number of the SignatureRequest List to return. Defaults to &#x60;1&#x60;. (optional, default to 1)</param>
        /// <param name="pageSize">Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;. (optional, default to 20)</param>
        /// <param name="query">String that includes search terms and/or fields to be used to filter the SignatureRequest objects. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestListResponse</returns>
        public HelloSign.Client.ApiResponse<SignatureRequestListResponse> SignatureRequestListWithHttpInfo(string? accountId = default(string?), int? page = default(int?), int? pageSize = default(int?), string? query = default(string?), int operationIndex = 0)
        {
            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };
            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (accountId != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "account_id", accountId));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (pageSize != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "page_size", pageSize));
            }
            if (query != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "query", query));
            }
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestList";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<SignatureRequestListResponse>("/signature_request/list", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Signature Requests Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.  Take a look at our [search guide](/api/reference/search/) to learn more about querying signature requests.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">Which account to return SignatureRequests for. Must be a team member. Use &#x60;all&#x60; to indicate all team members. Defaults to your account. (optional)</param>
        /// <param name="page">Which page number of the SignatureRequest List to return. Defaults to &#x60;1&#x60;. (optional, default to 1)</param>
        /// <param name="pageSize">Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;. (optional, default to 20)</param>
        /// <param name="query">String that includes search terms and/or fields to be used to filter the SignatureRequest objects. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestListResponse</returns>
        public async System.Threading.Tasks.Task<SignatureRequestListResponse> SignatureRequestListAsync(string? accountId = default(string?), int? page = default(int?), int? pageSize = default(int?), string? query = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<SignatureRequestListResponse> localVarResponse = await SignatureRequestListWithHttpInfoAsync(accountId, page, pageSize, query, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Signature Requests Returns a list of SignatureRequests that you can access. This includes SignatureRequests you have sent as well as received, but not ones that you have been CCed on.  Take a look at our [search guide](/api/reference/search/) to learn more about querying signature requests.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">Which account to return SignatureRequests for. Must be a team member. Use &#x60;all&#x60; to indicate all team members. Defaults to your account. (optional)</param>
        /// <param name="page">Which page number of the SignatureRequest List to return. Defaults to &#x60;1&#x60;. (optional, default to 1)</param>
        /// <param name="pageSize">Number of objects to be returned per page. Must be between &#x60;1&#x60; and &#x60;100&#x60;. Default is &#x60;20&#x60;. (optional, default to 20)</param>
        /// <param name="query">String that includes search terms and/or fields to be used to filter the SignatureRequest objects. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestListResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<SignatureRequestListResponse>> SignatureRequestListWithHttpInfoAsync(string? accountId = default(string?), int? page = default(int?), int? pageSize = default(int?), string? query = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (accountId != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "account_id", accountId));
            }
            if (page != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "page", page));
            }
            if (pageSize != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "page_size", pageSize));
            }
            if (query != null)
            {
                localVarRequestOptions.QueryParameters.Add(HelloSign.Client.ClientUtils.ParameterToMultiMap("", "query", query));
            }
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestList";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<SignatureRequestListResponse>("/signature_request/list", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestList", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Release On-Hold Signature Request Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](/api/reference/tag/Unclaimed-Draft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to release.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        public SignatureRequestGetResponse SignatureRequestReleaseHold(string signatureRequestId, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = SignatureRequestReleaseHoldWithHttpInfo(signatureRequestId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Release On-Hold Signature Request Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](/api/reference/tag/Unclaimed-Draft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to release.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        public HelloSign.Client.ApiResponse<SignatureRequestGetResponse> SignatureRequestReleaseHoldWithHttpInfo(string signatureRequestId, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestReleaseHold");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };
            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestReleaseHold";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SignatureRequestGetResponse>("/signature_request/release_hold/{signature_request_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestReleaseHold", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Release On-Hold Signature Request Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](/api/reference/tag/Unclaimed-Draft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to release.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        public async System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestReleaseHoldAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = await SignatureRequestReleaseHoldWithHttpInfoAsync(signatureRequestId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Release On-Hold Signature Request Releases a held SignatureRequest that was claimed and prepared from an [UnclaimedDraft](/api/reference/tag/Unclaimed-Draft). The owner of the Draft must indicate at Draft creation that the SignatureRequest created from the Draft should be held. Releasing the SignatureRequest will send requests to all signers.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to release.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<SignatureRequestGetResponse>> SignatureRequestReleaseHoldWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestReleaseHold");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestReleaseHold";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SignatureRequestGetResponse>("/signature_request/release_hold/{signature_request_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestReleaseHold", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send Request Reminder Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.  **NOTE**: This action can **not** be used with embedded signature requests.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to send a reminder for.</param>
        /// <param name="signatureRequestRemindRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        public SignatureRequestGetResponse SignatureRequestRemind(string signatureRequestId, SignatureRequestRemindRequest signatureRequestRemindRequest, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = SignatureRequestRemindWithHttpInfo(signatureRequestId, signatureRequestRemindRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send Request Reminder Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.  **NOTE**: This action can **not** be used with embedded signature requests.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to send a reminder for.</param>
        /// <param name="signatureRequestRemindRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        public HelloSign.Client.ApiResponse<SignatureRequestGetResponse> SignatureRequestRemindWithHttpInfo(string signatureRequestId, SignatureRequestRemindRequest signatureRequestRemindRequest, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestRemind");
            }

            // verify the required parameter 'signatureRequestRemindRequest' is set
            if (signatureRequestRemindRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestRemindRequest' when calling SignatureRequestApi->SignatureRequestRemind");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestRemindRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestRemindRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestRemind";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SignatureRequestGetResponse>("/signature_request/remind/{signature_request_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestRemind", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send Request Reminder Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.  **NOTE**: This action can **not** be used with embedded signature requests.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to send a reminder for.</param>
        /// <param name="signatureRequestRemindRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        public async System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestRemindAsync(string signatureRequestId, SignatureRequestRemindRequest signatureRequestRemindRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = await SignatureRequestRemindWithHttpInfoAsync(signatureRequestId, signatureRequestRemindRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send Request Reminder Sends an email to the signer reminding them to sign the signature request. You cannot send a reminder within 1 hour of the last reminder that was sent. This includes manual AND automatic reminders.  **NOTE**: This action can **not** be used with embedded signature requests.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to send a reminder for.</param>
        /// <param name="signatureRequestRemindRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<SignatureRequestGetResponse>> SignatureRequestRemindWithHttpInfoAsync(string signatureRequestId, SignatureRequestRemindRequest signatureRequestRemindRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestRemind");
            }

            // verify the required parameter 'signatureRequestRemindRequest' is set
            if (signatureRequestRemindRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestRemindRequest' when calling SignatureRequestApi->SignatureRequestRemind");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestRemindRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestRemindRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestRemind";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SignatureRequestGetResponse>("/signature_request/remind/{signature_request_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestRemind", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove Signature Request Access Removes your access to a completed signature request. This action is **not reversible**.  The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).  Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to remove.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void SignatureRequestRemove(string signatureRequestId, int operationIndex = 0)
        {
            SignatureRequestRemoveWithHttpInfo(signatureRequestId);
        }

        /// <summary>
        /// Remove Signature Request Access Removes your access to a completed signature request. This action is **not reversible**.  The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).  Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to remove.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public HelloSign.Client.ApiResponse<Object> SignatureRequestRemoveWithHttpInfo(string signatureRequestId, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestRemove");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };
            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestRemove";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/signature_request/remove/{signature_request_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestRemove", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove Signature Request Access Removes your access to a completed signature request. This action is **not reversible**.  The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).  Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to remove.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SignatureRequestRemoveAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await SignatureRequestRemoveWithHttpInfoAsync(signatureRequestId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Remove Signature Request Access Removes your access to a completed signature request. This action is **not reversible**.  The signature request must be fully executed by all parties (signed or declined to sign). Other parties will continue to maintain access to the completed signature request document(s).  Unlike /signature_request/cancel, this endpoint is synchronous and your access will be immediately removed. Upon successful removal, this endpoint will return a 200 OK response.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to remove.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<Object>> SignatureRequestRemoveWithHttpInfoAsync(string signatureRequestId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestRemove");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            var localVarContentType = HelloSign.Client.ClientUtils.SelectHeaderContentType(_contentTypes);

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestRemove";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/signature_request/remove/{signature_request_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestRemove", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send Signature Request Creates and sends a new SignatureRequest with the submitted documents. If &#x60;form_fields_per_document&#x60; is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        public SignatureRequestGetResponse SignatureRequestSend(SignatureRequestSendRequest signatureRequestSendRequest, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = SignatureRequestSendWithHttpInfo(signatureRequestSendRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send Signature Request Creates and sends a new SignatureRequest with the submitted documents. If &#x60;form_fields_per_document&#x60; is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        public HelloSign.Client.ApiResponse<SignatureRequestGetResponse> SignatureRequestSendWithHttpInfo(SignatureRequestSendRequest signatureRequestSendRequest, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestSendRequest' is set
            if (signatureRequestSendRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestSendRequest' when calling SignatureRequestApi->SignatureRequestSend");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestSendRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestSendRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestSend";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SignatureRequestGetResponse>("/signature_request/send", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestSend", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send Signature Request Creates and sends a new SignatureRequest with the submitted documents. If &#x60;form_fields_per_document&#x60; is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        public async System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestSendAsync(SignatureRequestSendRequest signatureRequestSendRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = await SignatureRequestSendWithHttpInfoAsync(signatureRequestSendRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send Signature Request Creates and sends a new SignatureRequest with the submitted documents. If &#x60;form_fields_per_document&#x60; is not specified, a signature page will be affixed where all signers will be required to add their signature, signifying their agreement to all contained documents.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<SignatureRequestGetResponse>> SignatureRequestSendWithHttpInfoAsync(SignatureRequestSendRequest signatureRequestSendRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestSendRequest' is set
            if (signatureRequestSendRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestSendRequest' when calling SignatureRequestApi->SignatureRequestSend");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestSendRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestSendRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestSend";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SignatureRequestGetResponse>("/signature_request/send", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestSend", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send with Template Creates and sends a new SignatureRequest based off of the Template(s) specified with the &#x60;template_ids&#x60; parameter.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        public SignatureRequestGetResponse SignatureRequestSendWithTemplate(SignatureRequestSendWithTemplateRequest signatureRequestSendWithTemplateRequest, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = SignatureRequestSendWithTemplateWithHttpInfo(signatureRequestSendWithTemplateRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send with Template Creates and sends a new SignatureRequest based off of the Template(s) specified with the &#x60;template_ids&#x60; parameter.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        public HelloSign.Client.ApiResponse<SignatureRequestGetResponse> SignatureRequestSendWithTemplateWithHttpInfo(SignatureRequestSendWithTemplateRequest signatureRequestSendWithTemplateRequest, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestSendWithTemplateRequest' is set
            if (signatureRequestSendWithTemplateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestSendWithTemplateRequest' when calling SignatureRequestApi->SignatureRequestSendWithTemplate");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestSendWithTemplateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestSendWithTemplateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestSendWithTemplate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SignatureRequestGetResponse>("/signature_request/send_with_template", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestSendWithTemplate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send with Template Creates and sends a new SignatureRequest based off of the Template(s) specified with the &#x60;template_ids&#x60; parameter.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        public async System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestSendWithTemplateAsync(SignatureRequestSendWithTemplateRequest signatureRequestSendWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = await SignatureRequestSendWithTemplateWithHttpInfoAsync(signatureRequestSendWithTemplateRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send with Template Creates and sends a new SignatureRequest based off of the Template(s) specified with the &#x60;template_ids&#x60; parameter.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestSendWithTemplateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<SignatureRequestGetResponse>> SignatureRequestSendWithTemplateWithHttpInfoAsync(SignatureRequestSendWithTemplateRequest signatureRequestSendWithTemplateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestSendWithTemplateRequest' is set
            if (signatureRequestSendWithTemplateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestSendWithTemplateRequest' when calling SignatureRequestApi->SignatureRequestSendWithTemplate");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestSendWithTemplateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestSendWithTemplateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestSendWithTemplate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SignatureRequestGetResponse>("/signature_request/send_with_template", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestSendWithTemplate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Signature Request Updates the email address and/or the name for a given signer on a signature request. You can listen for the &#x60;signature_request_email_bounce&#x60; event on your app or account to detect bounced emails, and respond with this method.  **NOTE**: This action cannot be performed on a signature request with an appended signature page.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to update.</param>
        /// <param name="signatureRequestUpdateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignatureRequestGetResponse</returns>
        public SignatureRequestGetResponse SignatureRequestUpdate(string signatureRequestId, SignatureRequestUpdateRequest signatureRequestUpdateRequest, int operationIndex = 0)
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = SignatureRequestUpdateWithHttpInfo(signatureRequestId, signatureRequestUpdateRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update Signature Request Updates the email address and/or the name for a given signer on a signature request. You can listen for the &#x60;signature_request_email_bounce&#x60; event on your app or account to detect bounced emails, and respond with this method.  **NOTE**: This action cannot be performed on a signature request with an appended signature page.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to update.</param>
        /// <param name="signatureRequestUpdateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignatureRequestGetResponse</returns>
        public HelloSign.Client.ApiResponse<SignatureRequestGetResponse> SignatureRequestUpdateWithHttpInfo(string signatureRequestId, SignatureRequestUpdateRequest signatureRequestUpdateRequest, int operationIndex = 0)
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestUpdate");
            }

            // verify the required parameter 'signatureRequestUpdateRequest' is set
            if (signatureRequestUpdateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestUpdateRequest' when calling SignatureRequestApi->SignatureRequestUpdate");
            }

            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestUpdateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestUpdateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestUpdate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SignatureRequestGetResponse>("/signature_request/update/{signature_request_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestUpdate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Signature Request Updates the email address and/or the name for a given signer on a signature request. You can listen for the &#x60;signature_request_email_bounce&#x60; event on your app or account to detect bounced emails, and respond with this method.  **NOTE**: This action cannot be performed on a signature request with an appended signature page.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to update.</param>
        /// <param name="signatureRequestUpdateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureRequestGetResponse</returns>
        public async System.Threading.Tasks.Task<SignatureRequestGetResponse> SignatureRequestUpdateAsync(string signatureRequestId, SignatureRequestUpdateRequest signatureRequestUpdateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HelloSign.Client.ApiResponse<SignatureRequestGetResponse> localVarResponse = await SignatureRequestUpdateWithHttpInfoAsync(signatureRequestId, signatureRequestUpdateRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update Signature Request Updates the email address and/or the name for a given signer on a signature request. You can listen for the &#x60;signature_request_email_bounce&#x60; event on your app or account to detect bounced emails, and respond with this method.  **NOTE**: This action cannot be performed on a signature request with an appended signature page.
        /// </summary>
        /// <exception cref="HelloSign.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="signatureRequestId">The id of the SignatureRequest to update.</param>
        /// <param name="signatureRequestUpdateRequest"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureRequestGetResponse)</returns>
        public async System.Threading.Tasks.Task<HelloSign.Client.ApiResponse<SignatureRequestGetResponse>> SignatureRequestUpdateWithHttpInfoAsync(string signatureRequestId, SignatureRequestUpdateRequest signatureRequestUpdateRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'signatureRequestId' is set
            if (signatureRequestId == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestId' when calling SignatureRequestApi->SignatureRequestUpdate");
            }

            // verify the required parameter 'signatureRequestUpdateRequest' is set
            if (signatureRequestUpdateRequest == null)
            {
                throw new HelloSign.Client.ApiException(400, "Missing required parameter 'signatureRequestUpdateRequest' when calling SignatureRequestApi->SignatureRequestUpdate");
            }


            HelloSign.Client.RequestOptions localVarRequestOptions = new HelloSign.Client.RequestOptions();

            var localVarContentType = "";
            var openApiTypes = signatureRequestUpdateRequest.GetOpenApiTypes();
            if (ClientUtils.HasFileType(openApiTypes))
            {
                ClientUtils.SetFormData(localVarRequestOptions, openApiTypes);
                localVarContentType = "multipart/form-data";
            }
            else
            {
                localVarContentType = "application/json";
                localVarRequestOptions.Data = signatureRequestUpdateRequest;
            }

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = HelloSign.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("signature_request_id", HelloSign.Client.ClientUtils.ParameterToString(signatureRequestId)); // path parameter
            localVarRequestOptions.Operation = "SignatureRequestApi.SignatureRequestUpdate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (api_key) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + HelloSign.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }
            // authentication (oauth2) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SignatureRequestGetResponse>("/signature_request/update/{signature_request_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignatureRequestUpdate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
